https://discourse.onlinedegree.iitm.ac.in/t/171999

So ONLY
write the FINAL script(s) to run in ```bash or ```python code fences.
"""


@app.post("/run")
async def run_task(task: str):
    """Execute a plain-English automation task."""
    response = await llm(system_prompt, task)
    print(f"\n游리 Running task:\n{task.strip()}\n")
    print(f"\n游리 {response}\n")

    results = []
    for language, code in re.findall(r"```(python|bash)\n(.*?)\n```", response, re.DOTALL):
        print(f"\n游리 Running {language} code:\n{code}\n")
        if language == "python":
            result = await execute_python(code)
        else:  # bash
            result = await execute_bash(code)
        results.append({"lang": language, **result})

    print(f"\n游리 Results:\n{results}\n")
    return {"response": response, "results": results}


@app.get("/read")
async def read_file(path: str):
    """Read contents of a file."""
    # Validate path is within /data
    path = os.path.normpath(path)
    if not path.startswith("/data/"):
        raise HTTPException(status_code=400, detail="Invalid path")
    if not os.path.exists(path):
        raise HTTPException(status_code=404, detail="File not found")
    return FileResponse(path)


@app.post("/execute/python")
async def execute_python(code: str):
    """Execute Python code directly."""
    proc = await asyncio.create_subprocess_exec(
        "python3",
        "-",
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate(code.encode())

    if proc.returncode != 0:
        print(f"\n游댮 Python execution failed:\n{stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"Execution failed: {stderr.decode()}")

    return {"stdout": stdout.decode(), "stderr": stderr.decode()}


@app.post("/execute/bash")
async def execute_bash(code: str):
    """Execute bash code directly."""
    proc = await asyncio.create_subprocess_exec(
        "bash",
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate(code.encode())

    if proc.returncode != 0:
        print(f"\n游댮 Bash execution failed:\n{stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"Execution failed: {stderr.decode()}")

    return {"stdout": stdout.decode(), "stderr": stderr.decode()}


@app.get("/")
async def read_root():
    """Serve the index.html file."""
    return FileResponse("static/index.html")


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
</code></pre><hr>

</body></html>